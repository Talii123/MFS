package nolongerused;

import javax.jdo.PersistenceManager;
import javax.jdo.annotations.Embedded;
import javax.jdo.annotations.Extension;
import javax.jdo.annotations.IdGeneratorStrategy;
import javax.jdo.annotations.NotPersistent;
import javax.jdo.annotations.PersistenceCapable;
import javax.jdo.annotations.Persistent;
import javax.jdo.annotations.PrimaryKey;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import friedman.tal.UniqueID;
import friedman.tal.jdo.IJDO;
import friedman.tal.mfs.timelines.ITimeline;
import friedman.tal.mfs.timelines.PublicTimelineID;
import friedman.tal.mfs.users.IUserAccount;
import friedman.tal.mfs.users.UserAccountJDO;
import friedman.tal.util.GUIDMaker;
import friedman.tal.util.PMF;

@PersistenceCapable
public class OldTimelineJDO implements ITimeline {
	
	@NotPersistent
	public static final Logger LOGGER = LoggerFactory.getLogger(OldTimelineJDO.class);

	@PrimaryKey
	@Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
	@Extension(vendorName = "datanucleus", key = "gae.encoded-pk", value="true")
	private String _encodedKey;
	
	@Persistent
	private UniqueID _publicID;
	
	/*@Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
	private String _timelineLookupKey;*/
	
	/*@Persistent
	@Embedded
	private PublicTimelineID _publicID;*/
	
	public OldTimelineJDO(UserAccountJDO owner) {
		this(owner, null);
		
		//owner.setTimeline(this);
		LOGGER.debug("autogenerating an ID for the timeline. (NOTE: it's generated by the application, not the datastore)");
		//this._publicID = makeID(null);  // note that outside of a transaction context, this has to happen before the timeline is added to the owning UserAccount object.
				
		//this._publicTimelineID = new PublicTimelineID();
		
		//this._publicID = String.valueOf(GUIDMaker.getUniqueLong());
	}
	
	public OldTimelineJDO(UserAccountJDO owner, String aPublicTimelineID) {
		owner.setTimeline(this);
		LOGGER.debug("Naming timeline '{}' ", aPublicTimelineID);
		// removed for compilation; see note below
		//this._publicID = makeID(aPublicTimelineID);  // note that outside of a transaction context, this has to happen before the timeline is added to the owning UserAccount object.
		
		//this._timelineLookupKey = aPublicTimelineID; //new PublicTimelineID(aPublicTimelineID);
		
		//this._publicID = Long.parseLong(aPublicTimelineID);
	}
	
	/*
	 * this is only commented out due to comiplation errors;  when this version of the class was in use, this code was used
	 * and it compiled correctly. 
	private UniqueID makeID(String anID) {
		UniqueID publicTimelineID;
		LOGGER.debug("anID: {}", anID);
		anID = (anID != null) ? anID.trim() : "";

		if (anID.length() > 0) {
			publicTimelineID = new PublicTimelineID(this, anID);
		}
		else {
			publicTimelineID = new PublicTimelineID(this, String.valueOf(GUIDMaker.getUniqueLong()));
		}

		
		/*PersistenceManager pm = PMF.getNewPM();
		try {
			// by setting a reference to the parent timeline inside the child PublicTimeline ID, we're already making it persistent
			//pm.makePersistent(publicTimelineID);
		} finally {
			pm.close();
		}*/ /*
		LOGGER.debug("returning publicTimelineID: {}", publicTimelineID);
		return publicTimelineID;
	}
*/	
	
	// TODO: probably should not be passing in userAccount as a separate arg, but need to make it accessible from Timeline in order to change this
	public static OldTimelineJDO from(ITimeline aTimeline, UserAccountJDO aUserAccount) {
		return aTimeline instanceof OldTimelineJDO ?  (OldTimelineJDO)aTimeline : new OldTimelineJDO(aUserAccount);
	}
	
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(IJDO.JDO_STR_START_TOKEN).append(this.getClass()).append(": ")
			.append("_encodedKey=").append(_encodedKey != null ? _encodedKey : "[null]").append(IJDO.JDO_PROPERTY_DELIMITER)
			.append("_publicID=").append(_publicID != null ? _publicID : "[null]").append(IJDO.JDO_PROPERTY_DELIMITER)
			.append(IJDO.JDO_PROPERTY_DELIMITER)
		.append(IJDO.JDO_STR_END_TOKEN);
				
		return sb.toString();
	}	
}
